TITLE:: SoundFileAnalysis
summary:: A simple system for non realtime soundfile analysis
categories::Non-Realtime


DESCRIPTION::


CLASSMETHODS::

METHOD::verbose

Post what's going on. (default == False)

METHOD::new

Return a new link::Classes/SoundFileAnalysis:: Object

METHOD::initAnalysisMethods

Return a function with a dictionary of basic analasys methods:

METHOD::basicAnalysisMethods
A dictionary with the tree keys: \trig, \average, \direct

definitionlist::
## trig
|| Write a value on receiveing a trigger

## average
|| Average all values in the file


## direct
|| Write a value on each frame

::


INSTANCEMETHODS::

METHOD::add

Add a new analysis method

ARGUMENT::name

Name for the method (a link::Classes/Symbol::)

ARGUMENT::type

One of currently three types:

definitionlist::
## trig
|| Write a value on receiveing a trigger

## direct
|| Write a value on each frame

## average
|| Average all values in the file

::


ARGUMENT::ugenFunc

A function that returns a UGen graph. It takes the sound signal and the soundfile object as arguments.


METHOD::analysisMethods

Returns a dictionary of functions of currently defined methods.



METHOD::analyzeFile

Analyze a sound file, using the defined analysis methods. This method returns an link::Classes/Event:: with the following information:
definitionlist::
## ~fileName, ~path, ~fileNumChannels
|| path and sound file information

## ~analysisStart, ~analysisDuration
|| What part of the file was analyzed

## ~dataDimensions
|| The results, each resulting from an analysis method (an link::Classes/Event::)

## ~dataTable
|| The above results ordered as a multidimensional array

::


ARGUMENT::path

Path to the soundfile

ARGUMENT::start

Start frame index for analysis

ARGUMENT::duration

Analysis duration in seconds

ARGUMENT::which

Which methods to use (an array of names as symbols). If none is given, use all.

ARGUMENT::callback

A function that is called when analysis is completed. It takes the result (an event) as argument.

ARGUMENT::maxDataPoints

A limit on the number of points added to the data.


METHOD::analyzeAll

Analyze all files given, returning a link::Classes/List:: of link::Classes/Event::s.

ARGUMENT::paths

A list of paths


EXAMPLES::
CODE::
// record a sound into a buffer
b = Buffer.alloc(s, s.sampleRate * 3, 1, bufnum: 1000);

(
SynthDef(\record, {|out|
	var in, rec;
	in = RLPF.ar(LFSaw.ar(300 * SinOsc.kr(0.4).range(0.5, 5)), Line.kr(12000, 100, 3));
	rec = RecordBuf.ar(in, b.bufnum, loop: 0, doneAction: 2);
	Out.ar(out, in);
};
).add
)

Synth(\record);

// write the file to analyze later
b.write("~/soundFileAnalysisExample.aiff".standardizePath,"aiff", "int24");

b.play; // maybe check if something is there

// initialize analysis
(
a = SoundFileAnalysis.new;

a.add(\centroid, \trig, {|sig|
	var fft = FFT(LocalBuf(2048, 1), sig);
	var x = SpecCentroid.kr(fft);
	[Impulse.kr(5), x]
});
a.add(\crest, \average, {|sig, soundfile| Crest.kr(sig, soundfile.numFrames) });
a.add(\FFTCrest, \direct, {|sig| var fft = FFT(LocalBuf(2048, 1), sig); FFT(LocalBuf(2048, 1), sig); FFTCrest.kr(fft, 200, 10000) });
)

// analyze the sound

x = a.analyzeFile("~/soundFileAnalysisExample.aiff".standardizePath, duration: 3, maxDataPoints: 3000);

// look at the data
x[\Centroid].postcs;
x[\Crest].postcs;
x[\FFTCrest].postcs;


// BONUS: how to tweak the analysis methods
(
Ndef(\centroid, {
	var sig = RLPF.ar( LFSaw.ar(300 * SinOsc.kr(0.4).range(0.5, 5)), Line.kr(12000, 300, 3));
	var fft = FFT(LocalBuf(2048, 1), sig);
	var x = SpecCentroid.kr(fft);
	x.poll(10);
	sig;
}).play;
)
::


SECTION::Tests
CODE::
(
a = SoundFileAnalysis.new;

a.add(\onsets, \trig, { |sig|
	var fft = FFT(LocalBuf(512, 1), sig);
	Onsets.kr(fft)
});
a.add(\fftcrest, \average, { |sig|
	FFTCrest.kr(FFT(LocalBuf(2048, 1), sig))
});

a.add(\slope, \average, { |sig|
	FFTSlope.kr(FFT(LocalBuf(2048, 1), sig))
});
a.add(\amplitude, \average, { |sig|
	Amplitude.kr(sig)
});

a.add(\test, \trig, { |sig|
	[Impulse.kr(2), 1, 2, 3]
});

a.add(\test2, \direct, { |sig|
	//DC.kr([10, 20, 30])
	Phasor.kr(0, 1, 1, inf);
});

a.add(\test3, \direct, { |sig|
	Phasor.ar(0, [10, 1], 1, inf);
});
);

// analyze single files
x = a.analyzeFile(Platform.resourceDir +/+ "sounds/a11wlk01.wav", callback: { "analysis completed".postln }, maxDataPoints: 6000);
x.postcs;"";
x[\test];
x[\test2].cs;
x[\test3].cs;
x[\test].as(Array).shape
x[\crest];
x[\onsets];


::
